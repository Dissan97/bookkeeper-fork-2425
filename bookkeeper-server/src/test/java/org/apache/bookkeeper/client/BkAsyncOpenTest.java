package org.apache.bookkeeper.client;

import org.jetbrains.annotations.NotNull;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CompletableFuture;

import static org.junit.Assert.*;

@RunWith(Parameterized.class)
public class BkAsyncOpenTest extends AbsBkOpen{


    private AsyncCallback.OpenCallback cb = null;
    private final Object ctx;

    CompletableFuture<LedgerHandle> future = new CompletableFuture<>();

    public BkAsyncOpenTest(long iid, BookKeeper.DigestType digestType,
                           byte[] passwd, @NotNull OpenCallbackType cbType, Object ctx,
                           TestOutcome outcome) {
        super(iid, digestType, passwd, outcome);

        if (cbType.equals(OpenCallbackType.VALID)){
            this.cb = new SyncCallbackUtils.SyncOpenCallback(future);
        } else if (cbType.equals(OpenCallbackType.INVALID)) {
            this.cb = new InvalidOpenCallback(future);
        }
        this.ctx = ctx;
    }

    private static final Collection<Object[]> BK_ASYNC_OPEN_PARAMETERS = Arrays.asList(new Object[][]{
            {-1, BookKeeper.DigestType.MAC, VALID_PASSWORD,OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.BK_EXCEPTION},
            {0, BookKeeper.DigestType.DUMMY, VALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.VALID},
            {0, BookKeeper.DigestType.MAC, VALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.VALID},
            {0, BookKeeper.DigestType.CRC32, VALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.VALID},
            {0, BookKeeper.DigestType.CRC32C, VALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.VALID},
            {0, BookKeeper.DigestType.CRC32C, INVALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.INVALID_PASSWORD},
            {0, BookKeeper.DigestType.CRC32C, null, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.INVALID_PASSWORD},
            {0, BookKeeper.DigestType.CRC32C, "".getBytes(), OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.INVALID_PASSWORD},
            {1, BookKeeper.DigestType.CRC32C, INVALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.BK_EXCEPTION},
            {0, BookKeeper.DigestType.MAC, VALID_PASSWORD, OpenCallbackType.INVALID, CTX_OPEN,
                    TestOutcome.BK_EXCEPTION},
            {0, BookKeeper.DigestType.MAC, VALID_PASSWORD, OpenCallbackType.VALID, CTX_OPEN,
                    BkOpenTest.TestOutcome.VALID},
            {0, BookKeeper.DigestType.MAC, VALID_PASSWORD, OpenCallbackType.VALID, null,
                    BkOpenTest.TestOutcome.VALID},
    });

    @Parameterized.Parameters
    public static Collection<Object[]> data() {
        return BK_ASYNC_OPEN_PARAMETERS;
    }

    @Test
    public void test() {

        boolean passed = false;
        try {
            bkClient.asyncOpenLedger(this.iid, this.digestType, this.passwd, this.cb, this.ctx);
            try (LedgerHandle lh = SyncCallbackUtils.waitForResult(this.future)){
                assertNotNull(lh);
                passed = lh.getId() == validId && this.outcome.equals(TestOutcome.VALID);
            }
        } catch (BKException e) {
            passed = ((e.getCode() == BKException.Code.NoSuchLedgerExistsOnMetadataServerException ||
                    e.getCode() == BKException.Code.UnauthorizedAccessException)
                    && outcome.equals(TestOutcome.BK_EXCEPTION)) ||
                    (e.getCode() == BKException.Code.UnauthorizedAccessException
                            && outcome.equals(TestOutcome.INVALID_PASSWORD));
        } catch (NullPointerException e){
            passed = outcome.equals(TestOutcome.NULL);
        }
        catch (InterruptedException e) {
            fail();
        }
        assertTrue(passed);
    }

    public static class InvalidOpenCallback implements AsyncCallback.OpenCallback{

        private final CompletableFuture<LedgerHandle> future;
        public InvalidOpenCallback(CompletableFuture<LedgerHandle> future) {
            this.future = future;
        }

        @Override
        public void openComplete(int rc, LedgerHandle lh, Object ctx) {
            SyncCallbackUtils.finish(BKException.Code.UnauthorizedAccessException, null, future);
        }
    }

    public enum OpenCallbackType{
        NULL,
        VALID,
        INVALID
    }
}
